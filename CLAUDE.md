# CLAUDE.md - AI Assistant Instructions

This document provides Claude Code with the context and patterns needed to work effectively with the F5 XC API Enriched codebase.

## Project Overview

**Purpose**: Automated enrichment pipeline for F5 Distributed Cloud OpenAPI specifications.

**Architecture Principles**:

- **Two-Folder Architecture**: Source specs (gitignored) → Generated output (gitignored, served by GitHub Pages)
- **ETag-Based Caching**: Bandwidth optimization preventing redundant downloads
- **Deterministic Output**: Same input always produces identical output
- **Semantic Versioning**: Automatic version bumping based on change detection

## Directory Structure

```text
f5xc-api-enriched/
├── specs/
│   ├── original/           # READ-ONLY - Downloaded from F5 (gitignored)
│   └── discovered/         # API discovery output
│       ├── openapi.json    # Full discovery spec (25MB, tracked in git)
│       └── session.json    # Discovery session metadata
├── docs/
│   ├── specifications/api/ # Generated specs (gitignored, GitHub Pages)
│   │   ├── *.json          # Domain-specific specs
│   │   ├── openapi.json    # Master combined spec
│   │   └── index.json      # Metadata index
│   ├── scalar/             # Scalar API documentation UI
│   └── swagger-ui/         # Swagger UI documentation
├── scripts/                # Python pipeline scripts
│   ├── pipeline.py         # Main unified pipeline
│   ├── download.py         # ETag-cached spec download
│   ├── enrich.py           # Enrichment (branding, grammar)
│   ├── normalize.py        # Normalization (refs, types)
│   ├── merge_specs.py      # Domain merging
│   ├── discover.py         # Live API discovery
│   ├── lint.py             # Spectral OpenAPI linting
│   ├── validate.py         # Live API validation
│   └── analyze_constraints.py  # Discovery constraint analysis
├── config/
│   ├── enrichment.yaml          # Enrichment rules
│   ├── normalization.yaml       # Normalization rules
│   ├── discovery.yaml           # Discovery configuration
│   ├── minimum_configs.yaml     # CLI metadata for 5 priority resources (Issue #152)
│   ├── default_minimum_configs.yaml  # Default templates for auto-generation
│   └── spectral.yaml            # Spectral linting ruleset
├── .github/workflows/
│   └── sync-and-enrich.yml # Main CI/CD workflow
├── reports/                # Generated reports (gitignored)
├── Makefile                # Build automation
├── .version                # Current semantic version
├── .etag                   # Last downloaded ETag
└── CHANGELOG.md            # Auto-generated changelog
```

## Read-Only Zones (CRITICAL)

**NEVER modify these directories/files**:

| Path | Reason |
|------|--------|
| `specs/original/` | Proprietary F5 specs, downloaded on schedule |
| `docs/specifications/api/` | Generated by pipeline, served by GitHub Pages |
| `specs/discovered/openapi.json` | Generated by discovery, tracked for CI/CD |
| `.version` | Managed by workflow, auto-incremented |
| `.etag` | Managed by download script |
| `CHANGELOG.md` | Auto-generated by workflow |

**Modification Pattern**: Change the pipeline scripts/config, not the outputs.

## Three Workflow Patterns

### 1. Discovery Workflow (VPN-Required, Local Only)

**Purpose**: Explore live F5 XC API to discover undocumented behavior and actual constraints.

**Prerequisites**:

- VPN connection to F5 XC API
- Environment variables: `F5XC_API_URL`, `F5XC_API_TOKEN`

**Commands**:

```bash
# Set credentials
export F5XC_API_URL="https://your-tenant.console.ves.volterra.io/api"
export F5XC_API_TOKEN="your-api-token"

# Run discovery (explores live API, generates specs/discovered/openapi.json)
make discover

# Push discovery data to GitHub for CI/CD consumption
make push-discovery

# Or combined: discover + push
make discover-and-push
```

**Outputs**:

- `specs/discovered/openapi.json` (25MB) - Full discovered API spec
- `specs/discovered/session.json` - Discovery session metadata
- `reports/discovery.log` - Discovery execution log

**Gotchas**:

- Discovery MUST run locally (VPN required)
- Never edit openapi.json manually - it's generated
- Always push discovery data for CI/CD to consume

### 2. Release Workflow (Automated via GitHub Actions)

**Purpose**: Sync specs from F5, run enrichment pipeline, create releases.

**Trigger**: Daily schedule, push to main, or manual dispatch.

**Flow**:

1. **Check Updates**: ETag comparison against F5 source
2. **Download**: Fetch new specs if changed
3. **Discovery Detection**: Check for committed discovery data
4. **Pipeline**: Enrich → Normalize → Merge → Lint
5. **Version Bump**: Auto-increment based on change type (see below)
6. **Release**: Create GitHub release with changelog
7. **Deploy**: Publish to GitHub Pages

**Change Detection** (PR #68):

The workflow monitors for changes in:

- `specs/original/` - Downloaded F5 source specifications
- `.etag` - Download cache file
- `scripts/` - Pipeline Python scripts
- `config/` - Configuration files (enrichment, normalization, discovery, spectral)
- `requirements.txt` - Python dependencies

**Version Bumping Logic**:

| Change Type | Files Changed | Version Bump | Example |
|-------------|---------------|--------------|---------|
| **Source specs** (new domains) | `specs/original/`, `.etag` + domain count ↑ | **Minor** | 1.0.15 → 1.1.0 |
| **Source specs** (no new domains) | `specs/original/`, `.etag` | **Patch** | 1.0.15 → 1.0.16 |
| **Pipeline changes** | `config/`, `scripts/`, `requirements.txt` | **Patch** | 1.0.15 → 1.0.16 |
| **Breaking changes** | Any + `[major]` or `BREAKING CHANGE` in commit | **Major** | 1.0.15 → 2.0.0 |

**Priority Order** (commit message overrides everything):

1. Explicit `[major]` or `BREAKING CHANGE` in commit message → Major bump
2. Source spec changes with new domains → Minor bump
3. Source spec changes without new domains → Patch bump
4. Pipeline/config/dependency changes → Patch bump
5. Unknown change types → Patch bump with warning

**Key Files**:

- `.github/workflows/sync-and-enrich.yml` - Main workflow
- `.version` - Current version (e.g., `1.0.14`)
- `CHANGELOG.md` - Auto-generated per release

### 3. Development Workflow (Local Testing)

**Purpose**: Local development, testing, and validation.

**Commands**:

```bash
# Full build (download → pipeline)
make build

# Quick rebuild (skip download, use existing specs)
make rebuild

# Individual steps
make download       # Download specs (ETag cached)
make pipeline       # Run enrichment pipeline
make lint           # Spectral OpenAPI linting
make validate       # Test against live API (needs credentials)

# Preview documentation
make serve          # http://localhost:8000

# Pre-commit hooks
make pre-commit-install  # Install git hooks
make pre-commit-run      # Run all hooks manually
```

**Pre-commit Hooks Run On Every Commit**:

1. F5 XC API Enrichment Pipeline (full rebuild)
2. Spectral linting (all 25 specs)
3. Security checks (gitleaks, detect-private-key)
4. Code quality (ruff, mypy, yamllint)
5. File hygiene (trailing whitespace, line endings)

## CLI Metadata Enrichment (Issue #152+)

**Purpose**: Enable AI assistants and CLI tools to generate working resource configurations.

**Features**:

Four OpenAPI extensions are added to schemas and specs:

1. **x-ves-minimum-configuration** (schema-level)
   - Description of minimum viable configuration
   - Required fields list
   - Example YAML configuration
   - Example xcsh CLI command
   - Applied to ALL resource schemas (5 configured + auto-generated for others)

2. **x-ves-cli-domain** (both schema and spec-level)
   - Domain classification (e.g., "virtual", "waf", "cdn")
   - At schema level: Resource classification
   - At spec level: Domain grouping metadata
   - Idempotent: Preserves existing values if present

3. **x-ves-required-for** (field-level)
   - Context-specific field requirements
   - Flags: minimum_config, create, update, read
   - Enables intelligent configuration generation

4. **x-ves-cli-aliases** (schema-level)
   - Alternative names for resources
   - Supports CLI command flexibility
   - Explicitly configured per resource

**Architecture**:

- **Stage 1 (Enrichment)**: MinimumConfigurationEnricher adds metadata to schemas
  - Configured resources use explicit config from `config/minimum_configs.yaml`
  - Unconfigured resources auto-generate from schema inspection
  - Uses DomainCategorizer for domain classification

- **Stage 2 (Merge)**: add_domain_metadata_to_spec() adds spec-level metadata
  - Spec info section gets x-ves-cli-domain from domain categorization
  - Spec index includes CLI domain metadata
  - Idempotent: Never overwrites existing values

**Configuration**:

- `config/minimum_configs.yaml`: Explicit configs for 5 priority resources
- `config/default_minimum_configs.yaml`: Default templates and patterns for auto-generation
- Pattern matching for resource type detection (e.g., "http_loadbalancerCreateRequest" → "http_loadbalancer")

**Testing**:

- 30 tests for explicit configurations (5 resources × parametrized patterns)
- 13 new tests for auto-generation and idempotency
- Total: 43 comprehensive tests with 82% code coverage

## Key Gotchas

### 1. Pre-commit Pipeline Always Runs

**Issue**: Every commit triggers full pipeline (~50 seconds).
**Detection**: Watch for `F5 XC API Enrichment Pipeline...Passed` in commit output.
**Prevention**: This is intentional - ensures spec consistency.

### 2. Discovery Data Must Be Pushed Separately

**Issue**: `make discover` generates data locally; CI/CD cannot access VPN.
**Detection**: Check if `specs/discovered/openapi.json` is tracked in git.
**Prevention**: Always run `make push-discovery` after discovery.

### 3. Specs Are Gitignored But Pipeline Generates Them

**Issue**: `docs/specifications/api/` is gitignored but served by GitHub Pages.
**Detection**: Directory empty after clone, populated after `make pipeline`.
**Prevention**: Run `make build` or `make pipeline` before serving docs locally.

### 4. ETag Caching May Skip Downloads

**Issue**: `make download` may report "No changes" even when you expect updates.
**Detection**: Check `.etag` file modification date.
**Prevention**: Use `make download-force` to bypass ETag cache.

### 5. Version Is Managed By Workflow

**Issue**: Manually editing `.version` causes version conflicts.
**Detection**: Merge conflicts in `.version` file.
**Prevention**: Let workflow manage version; use commit messages for bump hints.

### 6. Large Files Need Pre-commit Exception

**Issue**: `check-added-large-files` blocks files over 1MB by default.
**Detection**: Pre-commit fails with "exceeds X KB" message.
**Prevention**: Add exclusion in `.pre-commit-config.yaml` for intentionally large files.

### 7. Config/Script Changes Trigger Patch Releases (PR #68)

**Issue**: Changes to enrichment rules, pipeline scripts, or dependencies now trigger patch releases automatically.
**Detection**: Pushing changes to `config/`, `scripts/`, or `requirements.txt` to main creates a new release.
**Behavior**:

- Config/script changes → patch bump (e.g., 1.0.15 → 1.0.16)
- Documentation and GitHub Pages automatically deployed with new release
- CHANGELOG.md auto-generated with change type information

**Impact**: This is intentional and correct - pipeline changes affect output quality and should be versioned.

### 8. Documentation-Only Changes Skip Pipeline

**Issue**: CLAUDE.md or README.md changes trigger workflow but skip expensive pipeline execution.
**Detection**: Workflow log shows "Documentation-only changes detected - skipping pipeline".
**Prevention**: This is intentional optimization - docs changes don't need full pipeline execution.
**Impact**: Saves ~50 seconds per docs-only commit.

**Behavior**:

- Pure documentation commits (CLAUDE.md, README.md, docs/**/*.md, LICENSE only) → Skip 50-second pipeline
- No release created for docs-only changes
- Mixed changes (docs + code) → Full pipeline runs normally

## Claude-Specific Instructions

### When User Says "Fix Specs"

1. **Clarify**: Which specs? Original (can't modify), enriched (modify pipeline), or discovered (regenerate)?
2. **Pattern**: Modify `config/enrichment.yaml` or `config/normalization.yaml`, not the output files.
3. **Validate**: Run `make pipeline && make lint` to verify changes.

### When User Says "Run Discovery"

1. **Verify**: Check VPN connection and environment variables.
2. **Execute**: `make discover` (takes several minutes, explores 300+ endpoints).
3. **Commit**: `make push-discovery` to make data available for CI/CD.
4. **Validate**: Check `specs/discovered/session.json` for success metrics.

### When User Says "Create Release"

1. **Never Manual**: Releases are automated via GitHub Actions.
2. **Trigger**: Push to main or manual workflow dispatch.
   - Source spec changes → auto-release with patch/minor bump
   - Config/script changes → auto-release with patch bump (PR #68)
   - No relevant changes → workflow skips release
3. **Monitor**: Watch workflow run for completion.
4. **Verify**: Check GitHub Releases page for new release (v1.0.X).
5. **Documentation**: GitHub Pages automatically deployed with release.

### When User Says "Update Dependencies"

1. **Python**: Modify `requirements.txt`, run `make install`.
2. **Pre-commit**: Run `pre-commit autoupdate` for hook versions.
3. **Node**: Install via npm for Spectral CLI.
4. **Test**: Run `make pre-commit-run` to validate all hooks.

### When User Says "Debug Pipeline"

1. **Individual Steps**: Run `make enrich`, `make normalize`, `make merge` separately.
2. **Reports**: Check `reports/pipeline-report.json` for detailed metrics.
3. **Lint Issues**: Run `make lint` and check `reports/lint-report.json`.
4. **Verbose**: Add `--verbose` to pipeline commands for debug output.

## Environment Variables

| Variable | Purpose | Required For |
|----------|---------|--------------|
| `F5XC_API_URL` | F5 XC API endpoint URL (multi-environment support) | Pipeline defaults, Discovery, Validation |
| `F5XC_API_TOKEN` | API authentication token | Discovery, Validation |
| `F5XC_DEFAULT_NAMESPACE` | Default namespace for API requests | Pipeline defaults |
| `GITHUB_TOKEN` | GitHub API access (in workflows) | Releases, Issues |
| `DISCOVERY_ENRICHMENT_ENABLED` | Enable discovery enrichment | Pipeline (auto-set) |

## Multi-Environment Server Variables

The OpenAPI specifications support multi-environment deployments through server variables. This enables selecting different API endpoints and namespaces for production and development deployments directly in Swagger UI.

### Server Variable Configuration

**Current Variables** (in Swagger UI "Server variables" section):

- `api_url`: F5 Distributed Cloud API endpoint (default: `https://example-corp.console.ves.volterra.io`)
- `namespace`: Kubernetes-style namespace for environment separation (default: `default`)

**Server URL Template**:

```text
{api_url}/namespaces/{namespace}
```

### API URL Variable

The `api_url` variable allows you to specify different F5 XC API endpoints for different environments.

**Default Behavior**:

- Reads from `F5XC_API_URL` environment variable if available
- Falls back to: `https://example-corp.console.ves.volterra.io`

**Environment Examples**:

| Environment | API URL | Use Case |
|-------------|---------|----------|
| Production | `https://your-tenant.console.ves.volterra.io` | Production API calls |
| Staging | `https://your-tenant.staging.volterra.us` | Staging/Testing configurations |
| Custom | `https://your-tenant.custom-api.f5xc.io` | Custom F5 XC deployments |

**Generated URLs by Example**:

- API URL: `https://example-corp.console.ves.volterra.io`, Namespace: `production`
  → `https://example-corp.console.ves.volterra.io/namespaces/production`

- API URL: `https://example-corp.staging.volterra.us`, Namespace: `staging`
  → `https://example-corp.staging.volterra.us/namespaces/staging`

**Setting API URL**:

```bash
# Option 1: Environment variable
export F5XC_API_URL="https://your-tenant.staging.volterra.us"
# API spec will use this URL automatically

# Option 2: Override in API client/tool
# Use the Swagger UI or your API client to select a different api_url value
```

**Pattern**: Full HTTPS URL with protocol and domain (no trailing slash)

### Namespace Variable with Environment Support

The `namespace` variable now supports the `F5XC_DEFAULT_NAMESPACE` environment variable for consistent environment selection.

**Default Behavior**:

- Reads from `F5XC_DEFAULT_NAMESPACE` environment variable if available
- Falls back to: `default`

**Setting Namespace Defaults**:

```bash
# Option 1: Environment variable
export F5XC_DEFAULT_NAMESPACE="production"
# All generated specs will default to production namespace

# Option 2: Override in API client/tool
# Use the Swagger UI or your API client to select a different namespace value

# Option 3: GitHub branch aware (with CI/CD integration)
# Automatically maps branches to namespaces:
# - main → main
# - staging → staging
# - feature/issue-123 → feature-123
```

**Environment Examples**:

| Scenario | Environment Setup | Result |
|----------|-------------------|--------|
| Local development | `export F5XC_DEFAULT_NAMESPACE="default"` | All requests to default namespace |
| Staging environment | `export F5XC_DEFAULT_NAMESPACE="staging"` | All requests to staging namespace |
| Production deployment | `export F5XC_DEFAULT_NAMESPACE="production"` | All requests to production namespace |

### GitHub-Based Deployment Strategy

Map GitHub branches to namespaces automatically for multi-environment CI/CD:

- `main` branch → production namespace "main"
- `feature/issue-{num}` → feature namespace "feature-{num}" (development)
- `bugfix/issue-{num}` → bugfix namespace "bugfix-{num}" (development)
- `staging` branch → staging namespace "staging"
- Other branches → default namespace "default"

This enables:

- Separate production deployments (main namespace) from feature/bugfix work
- Independent namespace isolation prevents naming conflicts
- Zero-downtime deployments with namespace-based environment selection
- Automatic deployment targeting based on GitHub branch

### Using in Swagger UI

1. Open [Swagger UI documentation](https://robinmordasiewicz.github.io/f5xc-api-enriched/swagger-ui/)
2. Look for "Server variables" section
3. Select your deployment environment:
   - Tenant: `console` (or your tenant name)
   - Namespace: `main` (production) or your feature namespace
4. The computed URL updates automatically to reflect your selection
5. All API calls use the selected namespace

### Tenant Naming Convention

The `tenant` variable should use your **corporate identifier** rather than the service name ("console"). This prevents URL duplication in the computed server URL.

**Pattern**: `https://{tenant}.console.ves.volterra.io/namespaces/{namespace}`

**Examples**:

- Tenant: `example-corp`, Namespace: `main` → `https://example-corp.console.ves.volterra.io/namespaces/main`
- Tenant: `acme-inc`, Namespace: `staging` → `https://acme-inc.console.ves.volterra.io/namespaces/staging`
- Tenant: `your-company`, Namespace: `default` → `https://your-company.console.ves.volterra.io/namespaces/default`

**Naming Rules**:

- Lowercase alphanumeric characters with hyphens (RFC 1123 compliant)
- Use your organization or project identifier
- Avoid reusing "console" or other service names
- Examples: `example-corp`, `acme-inc`, `mycompany`, `project-name`

This convention makes it clear that the tenant value should be customized for your specific F5 XC account.

### Extensible Framework

The server variable framework is designed for future expansion. Current configuration file: `config/server_variables.yaml`

**Planned Future Variables**:

- `region`: Geographic region for multi-region deployments (Phase 2)
- `environment`: Explicit environment designation (Phase 2)
- `domain_prefix`: Industry-standard naming conventions like "example-" (Phase 3)

## Common Operations

### Add New Enrichment Rule

```yaml
# config/enrichment.yaml
acronyms:
  NEW_TERM: "New Term Expansion"
```

### Add New Normalization Rule

```yaml
# config/normalization.yaml
type_fixes:
  - pattern: "oldType"
    replacement: "newType"
```

### Skip Pre-commit Hooks (Emergency Only)

```bash
git commit --no-verify -m "emergency: fix critical issue"
```

### Force Full Rebuild

```bash
make clean && make build
```

### Check Discovery Data Age

```bash
jq '.started_at' specs/discovered/session.json
```

### Test Workflow Skip Logic

```bash
# Test docs-only early exit (should skip pipeline in ~5s)
echo "\n## Test" >> CLAUDE.md
git add CLAUDE.md
git commit -m "docs: test early exit"
git push

# Test workflow file detection (should create patch release)
# Edit .github/workflows/sync-and-enrich.yml (add comment), then:
git add .github/workflows/sync-and-enrich.yml
git commit -m "ci: test workflow detection"
git push

# Test config file detection (should create patch release)
echo "  # test: test" >> config/enrichment.yaml
git add config/enrichment.yaml
git commit -m "config: test config detection"
git push
```

## Anti-Patterns to Avoid

1. **Never edit `specs/original/`** - These are downloaded from F5.
2. **Never edit `docs/specifications/api/`** - These are generated by pipeline.
3. **Never manually edit `.version`** - Workflow manages versioning.
4. **Never commit to main directly** - Use feature branches.
5. **Never skip pre-commit hooks regularly** - They ensure consistency.
6. **Never hardcode credentials** - Use environment variables.
7. **Never run discovery without VPN** - API is not publicly accessible.

## Testing Changes

Before committing any changes:

```bash
# Run full pipeline
make pipeline

# Lint all specs
make lint

# Run all pre-commit hooks
make pre-commit-run

# If discovery-related, also run:
make discover-dry-run  # List endpoints without making requests
```
